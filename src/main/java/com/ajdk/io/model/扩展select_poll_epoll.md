4. 扩展select/poll、epoll
4.1 简述
由第三部分的NIO可知，多路复用把for循环的系统调用变成了一次调用，那么他具体是怎么实现的？
其实我们仔细思考一下就能知道，他主要实现就是在selector.select()，由他去阻塞和触发动作。然而在实现这些功能的时候，就用到了三种模型，select、poll、epoll。因为select和poll很相似，所以大家都会把他们归为一类。

4.2 select/poll
我们先来说说什么是select？
实现过程
    1 每一个socket调用select()方法后，socket的等待队列就会放线程的引用，该线程就是你调用select的那个线程
    2 当其中一个socket发送数据的时候，他会将每一个socket在等待队列中移除放入就绪队列，这就表明一定有一个客户端写了数据过来，但是注意，这并不表示所有都有客户端写了数据过来
    3 这时候唤醒主线程，然后去就绪队列中遍历找到客户端写的数据并返回

产生问题
    1 因为fd(file)是个数组，所以socket容量会有上限
    2 只要有一个socket写入就会遍历所有socket，虽然减少了空轮询问题，但是每次都要在所有socket中去找到已准备好的那个socket需要消耗性能

什么是poll？
    因为fd是个数组，所以容量会达到上限，而poll则将这个数据结构改成了链表，所以解决了select模型中上限的问题，但是遍历socket的问题还是存在
    select和poll的本质区别就是一个是用数组存放socket，一个是用链表存放，其他地方没有任何区别

4.3 epoll
    epoll和select/poll相比，采用了事件回调的机制，并且使用红黑树去维护注册的socket，如下图所示
实现过程：
    1 调用Selector.open的时候会创建一个eventpoll的文件，里面主要含有等待队列，rbr(红黑树)，就绪列表
    2 然后在建立连接的时候调用epoll_ctl函数将socket放入epitem中
    3 调用epoll_wait函数将线程放入等待队列中，等待数据过来时唤醒
    4 有数据写入的时候会触发epitem的回调方法，将该epitem移除并加入rdlist就绪列表中
    5 当有数据在就绪列表的时候，就会唤醒等待对列中的线程并处理数据
 这样通过红黑树来维护连接和通过就绪列表来处理数据就可以保证可以存放最大限度的socket数量，并且在唤醒线程处理去处理就绪列表的时候肯定都是需要处理并且已就绪的socket。完美的解决了select/poll中的问题
总结

epoll相较于select/poll的优势：
    1 采用了事件驱动的方式，可以处理大量的连接，效率更高。
    2 支持边缘触发(ET)和水平触发(LT)两种模式，可以更灵活地处理IO事件。
    3 记录了上次处理的位置，可以避免重复的遍历，更加高效。
    4 高效利用了内核空间和用户空间的交互，避免了复制文件描述符。

4.4 扩展话题
    对于epoll的一些扩展，有兴趣的可以了解下，不感兴趣可以略过

4.4.1 什么是ET和LT?
ET和LT是epoll工作模式中的两种触发方式，分别表示边缘触发（Edge Triggered）和水平触发（Level Triggered）。

 1 边缘触发（ET）
    在ET模式下，当一个文件描述符上出现事件时，epoll_wait函数只会通知一次，即只有在文件描述符状态发生变化时才会返回。如果应用程序没有处理完这个事件，那么下一次调用epoll_wait函数时，它不会再返回这个事件，直到下一次状态变化。
    ET模式下的事件处理更为高效，因为它只会在必要的时候通知应用程序，避免了重复通知的问题。但是，由于ET模式只在状态变化时通知一次，因此应用程序需要及时处理事件，否则可能会错过某些事件。

水平触发（LT）
    在LT模式下，当一个文件描述符上出现事件时，epoll_wait函数会重复通知应用程序，直到该文件描述符上的事件被处理完毕为止。如果应用程序没有处理完这个事件，那么下一次调用epoll_wait函数时，它会再次返回这个事件，直到应用程序处理完为止。
    LT模式下的事件处理比较简单，因为它会重复通知应用程序，直到应用程序处理完为止。但是，由于重复通知的问题，LT模式下可能会导致一些性能问题。同时，在LT模式下，应用程序需要及时处理事件，否则可能会导致文件描述符上的事件积压，影响系统的性能。

4.4.2 什么是惊群？
epoll的惊群（Thundering Herd）指的是多个线程或进程同时等待同一个epoll文件描述符上的事件，当文件描述符上出现事件时，内核会通知所有等待的线程或进程，但只有一个线程或进程能够真正处理该事件，其他线程或进程会被唤醒但不能处理该事件，从而造成资源浪费和性能降低的问题。
惊群问题是由于内核通知等待线程或进程的方式引起的。在epoll中，当文件描述符上出现事件时，内核会通知所有等待的线程或进程，而不是通知一个线程或进程。因此，如果有多个线程或进程等待同一个文件描述符，那么当该文件描述符上出现事件时，内核会通知所有等待的线程或进程，导致惊群问题。

为了解决惊群问题，可以采用以下两种方式：
    1 使用边缘触发（ET）模式：在ET模式下，当文件描述符上出现事件时，内核只会通知一个等待的线程或进程，从而避免了惊群问题。
    2 采用互斥量或条件变量等机制：在多个线程或进程等待同一个文件描述符时，可以使用互斥量或条件变量等机制来控制线程或进程的唤醒，从而避免惊群问题。



